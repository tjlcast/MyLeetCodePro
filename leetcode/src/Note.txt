java：
－－－－｜int[][] points = {{10,16}, {2,8}, {1,6}, {7,12}} ;
		Arrays.sort(points, ( x , y) -> x[0] == y[0] ? x[1] - y[1] : x[0] -y[0]); // good
		该用法为java8的Lambda表达式，λ表达式有三部分组成：参数列表，箭头（->），以及一个表达式或语句块。再例如：() -> { System.out.println("Hello Lambda!"); }
－－－－｜Future<?>范型不确定
－－－－｜HashMap的拷贝构造函数比默认构造函数的开销大得多

Greedy	：
－－－－｜这道题目是活动选择问题(Activity-Selection Problem)的变形。活动选择问题是《算法导论》里面关于贪心算法的第一个问题。这个问题是这样的，有一组活动，每个活动都有一个开始时间S和结束时间F，
		假设一个人在同一时间只能参加一个活动，找出一个人可以参加的最多的活动数量。
		给了一堆区间[start,end]，然后现在射箭的意思是箭在某一个位置，只要在这个点的区间内，那么他就可以射中 。
		如果几条线段重叠（集合s），那么这些线段中肯定有一条最左线段l，这些s集合中所有的线段满足，最左端点的坐标小于等于l的最右点。


Dp		：
－－－－｜降低需要处理的问题的规模（记忆化）
		f(n) = w(n)*f(n-1)+w(n-1)*f(n-2)+....+w(0) ;从右边进行计算，则所有的f(k)都已经计算。
		
		
回溯		：
－－－－｜https://leetcode.com/problems/word-search/#/description
		在二维数组上进行回溯，递归进入返回时注意状态还原。
－－－－｜如果是字符串，则可以使用子串传递给下一个状态。


Sort	：
－－－－｜
		 * 长度不同的字符比较可以通过结合两个字符传，从而转换为比较两个长度相同的字符串。
		 * Tips：
		 * 		compareTo()比较两个字符串的字典序。
－－－－｜  多段归并
           在多段归并中，选取段的段头一般使用堆排序。java中为PriorityQueue底层使用堆排序。


Two pointers:
－－－－｜
		设链表起点距离环的起点距离为a，圈长为n，当p1和p2相遇时，相遇点距离环起点距离为b，此时b已绕环走了k圈，则
		p1走的距离为a+b；
		p2速度为p1的两倍，p2走的距离为2*(a+b);
		p2走的距离为a+b+k*n=2*(a+b)，从而a+b=k*n即当p1走a步，p2走(k*n-b)步，当k=1时，则为(n-b)步;
		因此如何求环的起点？把p1拉回起点重新出发，p2从相遇点继续走，p1，p2每次均走一步，a步后，p1到达起点，p2也刚好到圈的起点。
		如何求环的长度？相遇后，p2再走一圈并统计长度就是圈长。


Equal Situations:
－－－－｜[编程题] 游历魔法王国
